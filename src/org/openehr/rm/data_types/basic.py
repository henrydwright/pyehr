"""The data_types.basic package, contains types for the concepts of bistate, 
state (in a state machine) and real-world entity identifiers (see the openEHR 
Common IM for a discussion on identifier types)."""

from typing import Optional

from org.openehr.rm.data_types import DataValue
from org.openehr.rm.data_types.text import DVCodedText

class DVBoolean(DataValue):
    """Items which are truly boolean data, such as true/false or yes/no answers. For such data, it is important to devise the meanings (usually questions in subjective data) carefully, so that the only allowed results are in fact true or false.
    
    Misuse: The DV_BOOLEAN class should not be used as a replacement for naively modelled enumerated types such as male/female etc. Such values should be coded, and in any case the enumeration often has more than two values."""

    value : bool
    """Boolean value of this item. Actual values may be language or implementation dependent."""

    def __init__(self, value: bool):
        self.value = value
        super().__init__()

    def is_equal(self, other: 'DVBoolean'):
        return (
            type(self) == type(other) and
            self.value == other.value
        )
    
    def as_json(self):
        return {
            "_type": "DV_BOOLEAN",
            "value": self.value
        }

class DVState(DataValue):
    """For representing state values which obey a defined state machine, such as a variable representing the states of an instruction or care process.

    DV_STATE is expressed as a String but its values are driven by archetype-defined state machines. This provides a powerful way of capturing stateful complex processes in simple data."""

    value : DVCodedText
    """The state name. State names are determined by a state/event table defined in archetypes, and coded using openEHR Terminology or local archetype terms, as specified by the archetype."""

    is_terminal: bool
    """Indicates whether this state is a terminal state, such as "aborted", "completed" etc. from which no further transitions are possible."""

    def __init__(self, value: DVCodedText, is_terminal: bool):
        self.value = value
        self.is_terminal = is_terminal
        super().__init__()

    def is_equal(self, other: 'DVState'):
        return(
            type(self) == type(other) and
            self.value == other.value and
            self.is_terminal == other.is_terminal
        )

class DVIdentifier(DataValue):
    """Type for representing identifiers of real-world entities. Typical identifiers include drivers licence number, social security number, veterans affairs number, prescription id, order id, and so on.

    DV_IDENTIFIER is used to represent any identifier of a real thing, issued by some authority or agency.

    Misuse: DV_IDENTIFIER is not used to express identifiers generated by the infrastructure to refer to information items; the types OBJECT_ID and OBJECT_REF and subtypes are defined for this purpose."""

    issuer: Optional[str]
    """Optional authority which issues the kind of id used in the id field of this object."""

    assigner: Optional[str]
    """Optional organisation that assigned the id to the item being identified."""

    id: str
    """The identifier value. Often structured, according to the definition of the issuing authority's rules."""

    type: Optional[str]
    """Optional identifier type, such as prescription, or Social Security Number. One day a controlled vocabulary might be possible for this."""

    def __init__(self, id: str, issuer : Optional[str] = None, assigner : Optional[str] = None, id_type : Optional[str] = None):
        # invariant: id_valid
        if id == "":
            raise ValueError("ID cannot be empty (invariant: id_valid)")
        self.id = id
        self.issuer = issuer
        self.assigner = assigner
        self.type = id_type
        super().__init__()

    def is_equal(self, other: 'DVIdentifier'):
        return (
            type(self) == type(other) and
            self.issuer == other.issuer and
            self.assigner == other.assigner and
            self.id == other.id and
            self.type == other.type
        )
    
    def as_json(self):
        # https://specifications.openehr.org/releases/ITS-JSON/development/components/RM/Release-1.1.0/Data_types/DV_IDENTIFIER.json
        draft = {
            "_type": "DV_IDENTIFIER",
            "id": self.id
        }
        if self.issuer is not None:
            draft["issuer"] = self.issuer
        if self.type is not None:
            draft["type"] = self.type
        if self.assigner is not None:
            draft["assigner"] = self.assigner
        return draft
